//! # Project Euler #45
//!
//! Link: https://projecteuler.net/problem=45
//!
//! Triangle, pentagonal, and hexagonal numbers are generated by the following
//! formulae:
//!
//!     Triangle   : T(n) = n (n + 1) / 2  = [0, 1, 3,  6, 10, 15, ...]
//!     Pentagonal : P(n) = n (3n - 1) / 2 = [0, 1, 5, 12, 22, 35, ...]
//!     Hexagonal  : H(n) = n (2n - 1)     = [0, 1, 6, 15, 28, 45, ...]
//!
//! It can be verified that
//!
//!     T(285) = P(165) = H(143) = 40,755
//!
//! Find the next triangle number that is also pentagonal and hexagonal.
//!
//! ## Implementation
//!
//! This is a naive implementation. We implement each sequence as an iterator,
//! and advance each iterator until they are all equal.
//!
//! There are more mathematically rigorous algorithms, e.g.
//! https://loriculus.org/blog/euler-45/
//!
//! ## Discussion
//!
//! Hacker News: https://news.ycombinator.com/item?id=45941613
//!
//! Someone posted the loriculus blog post to Hacker News.
//!
//! In the comments, someone else posted the naive solution in Haskell.
//!
//! I wrote the naive solution in Rust.
//!
//! ## Solution
//!
//!     $ time cargo run --release
//!        Compiling p45 v0.1.0 (/Users/csb/Dev/practice/euler/p45)
//!         Finished `release` profile [optimized] target(s) in 0.15s
//!          Running `target/release/p45`
//!     0
//!     1
//!     40755
//!     1533776805
//!     57722156241751
//!     2172315626468283465
//!     cargo run --release  2.94s user 0.02s system 94% cpu 3.127 total

use std::cmp::Ordering;


// Triangle numbers
// ---------------------------------------------------------------------------

struct Triangle(usize);

impl Iterator for Triangle {
    type Item = usize;

    fn next(&mut self) -> Option<usize> {
        let i = self.0;
        self.0 += 1;
        Some(i * (i + 1) / 2)
    }
}


// Pentagonal numbers
// ---------------------------------------------------------------------------

struct Pentagonal(usize);

impl Iterator for Pentagonal {
    type Item = usize;

    fn next(&mut self) -> Option<usize> {
        let i = self.0;
        self.0 += 1;
        Some(i * (3 * i).wrapping_sub(1) / 2)
    }
}


// Hexagonal numbers
// ---------------------------------------------------------------------------

struct Hexagonal(usize);

impl Iterator for Hexagonal {
    type Item = usize;

    fn next(&mut self) -> Option<usize> {
        let i = self.0;
        self.0 += 1;
        Some(i * (2 * i).wrapping_sub(1))
    }
}


// Combine
// ---------------------------------------------------------------------------

struct Combine<L, R>(L, R);

impl<L, R> Iterator for Combine<L, R>
where
    L: Iterator<Item = usize>,
    R: Iterator<Item = usize>,
{
    type Item = usize;

    fn next(&mut self) -> Option<Self::Item> {
        let mut l = self.0.next().unwrap();
        let mut r = self.1.next().unwrap();

        loop {
            match usize::cmp(&l, &r) {
                Ordering::Equal => return Some(l),
                Ordering::Less => l = self.0.next().unwrap(),
                Ordering::Greater => r = self.1.next().unwrap(),
            }
        }
    }
}


// Main
// ---------------------------------------------------------------------------

fn main() {
    let search = Combine(Triangle(0), Combine(Pentagonal(0), Hexagonal(0)));
    for val in search.take(6) {
        println!("{}", val)
    }
}
